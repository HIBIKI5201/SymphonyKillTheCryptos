# インゲームループのアーキテクチャ解析レポート

## 1. はじめに

本レポートは、Unityプロジェクト `SymphonyKillTheCryptos` におけるインゲームのメインループを司る `InGameLoopUseCase.cs` のアーキテクチャを分析したものです。既に作成されている `architecture_report.md` で示された「Unityフレームワークを活用しながらUnityライフサイクルから独立した、より洗練されたクリーンアーキテクチャ」というプロジェクトの設計思想を踏まえ、`InGameLoopUseCase` がその原則にどのように適合しているか、また今後の改善点について考察します。

## 2. InGameLoopUseCase の概要

`InGameLoopUseCase` は、ゲームのメインループ、すなわちフェーズ遷移やターン管理など、インゲーム全体の進行を管理する役割を担っています。主要なゲームイベントを発火することで、他のUseCaseやPresenterに処理を促すハブとしての機能も果たします。

### 目的と責務

*   ゲームの開始、ターン進行、フェーズ遷移（プレイヤーフェーズ、敵フェーズ）、ゲーム終了といった主要なゲームフローの制御。
*   関連するUseCase（`CardUseCase`, `LevelUseCase`, `WaveUseCase`）との連携により、具体的なゲームロジックの実行を調整。
*   ゲーム進行に伴うイベント（`OnGameStarted`, `OnTurnStarted` など）の発火。

### 主要なイベント

*   `OnGameStarted`: ゲーム開始時に発火
*   `OnTurnStarted`: 各ターンの開始時に発火
*   `OnPlayerPhaseStarted`: プレイヤーフェーズ開始時に発火
*   `OnEnemyPhaseStarted`: 敵フェーズ開始時に発火
*   `OnTurnEnded`: 各ターンの終了時に発火
*   `OnGameEnded`: ゲーム終了時に発火

これらのイベントは、Presenter層などが購読することで、UseCase層のロジックに直接依存することなくUIの更新や演出を行うための重要な接点となっています。

### 他のUseCaseとの連携

コンストラクタインジェクションを通じて以下のUseCaseと連携しています。

*   `_cardUseCase`: カードの使用や管理に関する処理を担当。
*   `_levelUseCase`: プレイヤーのレベルアップやノード選択に関する処理を担当。
*   `_waveUseCase`: ウェーブの進行や管理に関する処理を担当。

これにより、`InGameLoopUseCase` は自身が直接すべてのゲームロジックを持つのではなく、各専門分野のUseCaseに処理を委譲することで、責務の分離が図られています。

## 3. インゲームループのシーケンス解析

`InGameLoopUseCase` の主要なメソッドと、それらが織りなすインゲームループのシーケンスを解析します。

### `StartGameAsync()`

ゲーム全体の開始をトリガーする非同期メソッドです。

1.  `OnGameStarted` イベントを発火。
2.  `InitializeGame()` を呼び出し、ゲームの初期化を実行。
3.  `RunGameLoop()` を呼び出し、メインのゲームループを開始。
4.  `RunGameLoop()` が完了したら、`OnGameEnded` イベントを発火。

### `InitializeGame()`

ゲーム開始時の初期化処理をカプセル化しています。現在の実装では `Task.Delay(100)` のみですが、コメントアウトされているように以下の具体的な処理が今後実装されるべき箇所です。

*   プレイヤーデータロード
*   カードデッキ初期化
*   最初のウェーブ設定

### `RunGameLoop()`

ゲーム終了条件が満たされるまで無限ループでターンの進行を管理する、インゲームの中核となるメソッドです。

1.  **ターン開始**:
    *   `OnTurnStarted` イベントを発火。
    *   現在のウェーブ情報をログ出力。
2.  **プレイヤーフェーズ**:
    *   `OnPlayerPhaseStarted` イベントを発火。
    *   `HandlePlayerPhase()` を呼び出し、プレイヤーの行動（カード選択、ターゲット選択など）を処理。
    *   プレイヤーフェーズの終了をログ出力。
3.  **敵フェーズ**:
    *   `OnEnemyPhaseStarted` イベントを発火。
    *   `HandleEnemyPhase()` を呼び出し、敵AIの行動を処理。
    *   敵フェーズの終了をログ出力。
4.  **ターン終了**:
    *   `OnTurnEnded` イベントを発火。
5.  **レベルアップ処理**:
    *   `_levelUseCase.LevelUpQueue` からレベルアップイベントを検知し、あれば以下の処理を実行。
        *   `_levelUseCase.WaitLevelUpSelectAsync()` を呼び出し、UIからのノード選択を非同期で待機。
        *   選択されたノードの効果を適用する処理（現在はコメントアウト）。
6.  **ウェーブ遷移判定**:
    *   `CheckWaveCompleted()` を呼び出し、現在のウェーブが完了したかチェック。
    *   完了していれば `_waveUseCase.NextWave()` を呼び出し、次のウェーブへ移行。
    *   次のウェーブがなければゲームループを終了 (`break`)。
7.  **ターン間待機**: `Task.Delay(1000)` によるターン間の待機（仮実装）。

### `HandlePlayerPhase()`

プレイヤーフェーズの詳細な処理を担う抽象的なメソッドです。プレイヤーからの入力（カード選択、ターゲット選択）を待ち、`CardUseCase` などの関連するUseCaseを呼び出すロジックが実装される予定です。

### `HandleEnemyPhase()`

敵フェーズの詳細な処理を担う抽象的なメソッドです。敵AIの行動ロジックを実装し、`CardUseCase` などの関連するUseCaseを呼び出すロジックが実装される予定です。

### `CheckWaveCompleted()`

現在のウェーブ完了条件をチェックするメソッドです。現在は `return true;` の仮実装となっており、全ての敵が倒されたかなどの具体的な条件ロジックが実装される必要があります。

## 4. 既存のアーキテクチャ原則との整合性

`InGameLoopUseCase` は、既存の `architecture_report.md` で評価されたプロジェクトのアーキテクチャ原則と非常に高い整合性を持っています。

*   **Unityライフサイクルからの独立性**: `MonoBehaviour` を継承しておらず、純粋なC#クラスとして設計されています。ゲームの進行は `Task` ベースの非同期処理によって制御されており、Unityの `Update` メソッドのようなライフサイクルイベントに直接依存していません。
*   **責務の分離**: ゲームのメインループ制御という単一の責務に集中しており、カード処理、レベル管理、ウェーブ管理といった具体的なロジックはそれぞれ `CardUseCase`, `LevelUseCase`, `WaveUseCase` に委譲されています。
*   **依存性注入 (DI)**: コンストラクタを通じて必要なUseCaseのインスタンスを受け取っており、明確なDIが適用されています。これにより、各UseCase間の結合度が低く保たれ、テスト容易性や保守性が向上しています。
*   **イベント駆動による連携**: `OnGameStarted` などのイベントを通じて、Presenter層や他のシステムとの連携を図っています。これにより、`InGameLoopUseCase` は具体的なUIや演出の実装に依存することなく、ゲームの進行状況を外部に通知できます。

## 5. 改善提案とToDo

現在の `InGameLoopUseCase` は、アーキテクチャの骨格としては非常に優れていますが、具体的なゲームロジックの実装に伴い、以下の点がToDoとして挙げられます。

1.  **ゲーム終了条件の具体的な実装**:
    `RunGameLoop` 内の `while (true)` に代わる、適切なゲーム終了条件（例: プレイヤーの敗北、全ウェーブクリア、特定のボス撃破など）を `InGameEntity` や `WaveUseCase` などと連携して定義し、ループの終了を制御する必要があります。

2.  **レベルアップノード適用処理の追加**:
    `// 選択されたノードの効果を適用するUseCaseを呼び出します。` の箇所に、選択された `LevelUpgradeNode` の効果をプレイヤーキャラクターやゲーム状態に適用するための具体的なロジック、あるいは別のUseCase（例: `ApplyLevelUpEffectUseCase` のようなもの）の呼び出しを実装する必要があります。

3.  **`InitializeGame()` の具体的な処理実装**:
    プレイヤーデータのロード、カードデッキの初期化、最初のウェーブ設定など、ゲーム開始に必要な具体的な初期化処理を実装します。これらの処理も、それぞれの責務に応じたUseCase（例: `PlayerUseCase`, `DeckUseCase`, `WaveUseCase`）と連携して行うのが望ましいです。

4.  **`HandlePlayerPhase()` および `HandleEnemyPhase()` の具体的な処理実装**:
    プレイヤーフェーズでは、プレイヤーからの入力受付、カードの使用（`_cardUseCase` の呼び出し）、ターゲット選択などのロジックを実装します。敵フェーズでは、敵AIの行動決定、攻撃（`_cardUseCase` や `CombatSystem` の利用）などのロジックを実装します。これらは、ゲームのコアなインタラクションロジックとなるため、十分な設計とテストが必要です。

5.  **`CheckWaveCompleted()` の実装**:
    現在のウェーブ内の全ての敵が倒されたか、または特定のウェーブ終了条件が満たされたかを判断する具体的なロジックを実装します。これは `WaveUseCase` や、現在の敵の数を管理する `EnemyManager` のようなシステムと連携して実現されるべきです。

6.  **ロギングの一元化**:
    `architecture_report.md` でも指摘されているように、現在の `Debug.Log` によるログ出力はUseCase層の純粋性を損なう可能性があります。外部のロギングサービス（インフラストラクチャ層）を導入し、UseCase層ではログメッセージを渡すのみに留めることで、よりクリーンな設計を目指せます。

これらのToDoを順次実装していくことで、`InGameLoopUseCase` はより堅牢で機能豊富なインゲームループとして完成に近づくでしょう。